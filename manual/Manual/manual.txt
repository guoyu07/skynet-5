

### 1. What is Skynet?[Skynet Framework is powerful, easy to use GNU/GPL licensed remote control package and cluster-based network connections builder written in PHP. 
With Skynet you can create different instances of Skynet (called "clusters") and place them on different servers and then connects with them and sending data between them.]

Skynet clusters works on request-response architecture as peer-to-peer clusters. They can connects between itselfs, requesting data, responds for them and more. Skynet have self-replication and self-update mechanisms, so you can clone or update your clusters even by remote easy access. Event-listener architecture implemented in Skynet allows you to create your own Event Listeners with easy to use API and allow you to expand Skynet's capabilities according to your needs. Skynet can operate in two modes - as PHP script administrated by browser and in PHP CLI. Thanks to both of these features Skynet offers console interface for quick and easy commands sending and parameters to other clusters. Skynet clusters work on dynamically created databases based on information from other clusters, requests and responses. Framework also have powerful logging system works on .txt files and database. Skynet is ONLY ONE FILE compiled from source classes (compiler is included). This feature allows you to operate Skynet easily using a single file from any location.

image: img/skynet.png

[NOTE: Skynet can be some of kind C&C service and can offers powerful possibilites with this. Please do not use Skynet for illegal purposes.]

## Most important features of Skynet: 

- Peer to peer clusters architecture
- Requesting and responding data via internal connections based on easy to use parameters
- Self updating registry about other clusters
- Broadcast mode (clusters to clusters | many-to-many peer-to-peer connections)
- Event Listeners based, easy to extend architecture of API
- It is only one file whitch is compiling from sources (you can extends Skynet by your own methods and compile all into single file)
- Powerful event log system
- Build-in console 
- Works in two modes: browser and CLI
- Easy to integration with tools like CRON
- Remote code execution
- Remote shell access
- Remote files transfers
- Administration panel via browser
- PDO multiple database engines support
- Self-update engine (even via remote)
- Self-clone engine (even via remote)
- Easy to extends and customization
- Factory based connections adapters (you can implements you own connection methods)
- Factory based data encryption (you can implements you own algorythms)
- Factory based event and logger listeners (you can create your own listeners and data loggers)
- Sending responses via email engine included
- Sleep and wakeup clusters commands included
- Full API documentation in PHPDOC
- It's all in one

[Skynet Framework is under GNU/GPL license, so it's absolutely free to use but if you like it and think that Skynet is helpful to you - you can donate to the project with BTC.
Ok, so let's start with Skynet:]


### 2. Getting startedSkynet Framework actual builds are hosted on GitHub. All you need to do is to download or clone repository and put it on your server.
It is preferred to start testing (if you using it at first time) on localhost server. After download and unpack archive or clone repository you will se some files and directories.


### 2.1. Getting Skynet from GitHUBGet Skynet from GitHub here: [link]http://github.com/szczyglinski/skynet[//]http://github.com/szczyglinski/skynet[/link]
You can download or clone repository. Remember that Skynet is still in development, so check sometimes for newest versions.



### 2.2. RequirementsSkynet Framework requires these components for work:

- Webserver with PHP 5.5+ interpreter
- PDO extension (for databases connections) 
- CURL extension (for CURL connections)

Skynet works on PHP5 and PHP7.


### 2.3. Skynet files structureAfter downloaded and unpacked (or cloned) repository you should see files structure of Skynet:

- [_compiled/] - compiled standalone versions will be placed here by default
- [_download/] - folder for downloaded files
- [db_schemas/] - .sql files for database schema (if you will create database manualy, in other case Skynet do it automaticaly)
- [logs/] - log files
- [manual/] - manual and API documentation
- [src/] - Skynet core, source classes
- [dev.php] - Non-compiled Skynet cluster (works on classes from [i]src/[/i] directory via autoloader)
- [skynet.php] - Compiled Skynet cluster (all classes are compiled into single standalone file)
- [compile.php] - Comilater script whitch compiling sources from [i]/src[/i] folder into single standalone file
- [keygen.php] - Skynet Key ID generator
- [pwdgen.php] - Password hash to Skynet Panel generator
- [README.MD] - Readme file
- [CHANGELOG.txt] - Changelog
- [TODO.txt] - TO DO LIST in next versions
- [LICENSE.txt] - License

As you see you have two versions of Skynet cluster by default: 

- [dev.php] - version with autoloader works on classes from [i]src/[/i] directory. You can use this version for development and tests
- [skynet.php] - compiled version with all classes from [i]src/[/i] directory included itself. This is the "production version" - one single file to put on server after compile from [i]src/[/i]

You can work on this two versions (when you launch both you will see that these two works exacly the same at now), but the idea od Skynet clusters is to operate on standalone compiled versions called here "clusters".


### 2.4. How Skynet works?An "idea" od Skynet is peer-to-peer based network communication between standalone clusters. You can see one of that created clusters in downloaded repository - it's called [i]skynet.php[/i].
You can create many clusters like that and then connects them with theirselfs. At the beginning you can simple copy [i]skynet.php[/i] to another file, e.g. [i]skynet2.php[/i] - if you do this you will have two Skynet clusters. 
At next,  you can create more, e.g. [i]skynet3.php[/i], [i]skynet4.php[/i], etc. Finally you can put them on different servers if you want. All of there standalone clusters will build your network.

At first launch of every cluster, Skynet will build database (SQLite is default and is recomennded). Every cluster creates their own database file named [i].CLUSTER_NAME.db[/i] (if SQLite is used). Of course you can use antother database engine (e.g. MySQL) and then Skynet will work on database like that, but SQLite is preferred. This is the idea: one cluster + one database file. From now, Skynet will store data about another clusters in their own database. This clusters list will be at next sended to another registered clusters so clusters knowed by one cluster will be shared with another cluster and added to their database. Every cluster will know about other clusters, that's the idea of this network. 

When at least one another cluster is knowed by your cluster you are allowed to share data and commands between them. Sending data between clusters is based on request-response architecture: one cluster sends request to another, and the another creates response from request then returns it to requesting one. With more that one cluster those requests and responses can be sending over whole network. Skynet resends information about knowed (registered) clusters to anothers when connects to them, so if you have 3 clusters, e.g. [i]skynet1.php[/i], [i]skynet2.php[/i], [i]skynet3.php[/i] you need to connect them each other at first. How to do this? When you connect first cluster with second cluster at first time the second cluster will get and store address of first cluster in their database and the first cluster will store address of second cluster. At now, if you connect second cluster with cluster number three, the cluster numer three will get (and store) address of second cluster... and the first cluster. It's not the end, becose after that, cluster number three will connect with first cluster and sends them their address. At now, every clusters will "see" each other. If you then add another - four cluster and connect to it from cluster one - all of clusters will receive information about new cluster (becose cluster one will inform them).

When Skynet knows about another clusters then starts broadcasting to all of them and allows to sending them requests (addressed to specified clusters, or adressed to whole network) and receiving responses from them. Every cluster is a sender and responder at once, so communication is in two-sides. Every request can have prepared parameters and commands specified by cluster or by user (and other cluster can responds for them with defined action).


### 2.5. First launchIf you have unpacked repository from GitHub put all of files from it on your localhost (or other) server, e.g. [i]localhost/skynet/[/i] and then launch in your browser:

-------- PHP code --------http://localhost/skynet/dev.php-------- !PHP code --------
(non-compiled developer version)

or

-------- PHP code --------http://localhost/skynet/skynet.php-------- !PHP code --------
(compiled version)

At now you will see the same on both of them - Skynet Control Panel.
This panel shows you informations about Skynet status and connections to another clusters. This panel also allows you to easy browse stored in database connections logs.
As you see, Skynet is not connected to any cluster and shows you 2 warnings - about empty password and empty [i]SkynetKeyID[/i]. By default, after you download Skynet these two fields are set to start values - you will need to configure them itself.
At first, let's try to generate [i]SkynetKey ID[/i] - this is the unique identifier of your clusters network. All of your clusters must have SAME KEY ID to allow connections between them. For security reasons Skynet cluster is checking this key in every connection. If requested key not match to cluster key then response is not generated.

To generate your Key, launch key generator included in package:

-------- PHP code --------http://localhost/skynet/keygen.php-------- !PHP code --------

This keygen generates randomly key in every launch. When you generate you key, place them into your Skynet config file:

-------- PHP code --------/src/SkynetUser/SkynetConfig.php-------- !PHP code --------

or/and in:

-------- PHP code --------/skynet.php-------- !PHP code --------

if you launched compiled version (remember that after compiling all configuration data from [i]/src[/i] are includes into standalone file)

Put [i]KEY ID[/i] into:

-------- PHP code --------const KEY_ID-------- !PHP code --------
(default here is: 1234567890, replace it with your Key)

Now, let's go to admin password hash generator. This password is using for accessing to your Skynet Control Panel. By default, this password is not set, so you must create one.
Skynet needs hash of the password, not the plain text of it. To generate password hash go to:

-------- PHP code --------http://localhost/skynet/pwdgen.php-------- !PHP code --------

Put your password into input, click on "Generate hash" and place generated hash into config file or/and into compiled version.

-------- PHP code --------const PASSWORD-------- !PHP code --------


Ok, let's back to your Skynet Control Panel:

-------- PHP code --------http://localhost/skynet/dev.php-------- !PHP code --------

or

-------- PHP code --------http://localhost/skynet/skynet.php-------- !PHP code --------

You should now see request for password. Log in with it.
At now, you have simple preconfigured Skynet but no connections yet (becose you have only 2 clusters (dev.php and skynet.php) at now.
Let's try to connect them.

In console at the bottom of window of Skynet Control Panel type:

-------- PHP code --------@connect CLUSTER_ADDRESS-------- !PHP code --------

where [i]CLUSTER_ADDRESS[/i] will be second cluster ([i]http://localhost/skynet/skynet.php[/i] if you're in [i]/dev.php[/i] and [i]http://localhost/skynet/dev.php[/i] if you're in [i]/skynet.php[/i])
At next, click on "Send request" button.

You should see information about connection with second cluster and the second cluster address should be stored into database.
Good. Now you have two working clusters. Let's try to create different clusters, e.g. by copying [i]skynet.php[/i] into [i]skynet2.php[/i], etc. and try to connect with them.

[REMEMBER:] All of your clusters MUST HAVE the same Skynet Key ID.


### 3. Request and ResponseSkynet works on request-response based architecture. After sender sends request to responder, responder reads request and generates response for it. Every request is authorized by user-defined Skynet Key ID - unique for every clusters network. Inside code - request is a list of parameters and commands. Those parameters can be set by code (e.g. by Event Listener) or 'handly' via built-in console or command line in CLI mode. Second part is response - an object whitch is generated when request arrives. Response can be generated with built-in in Skynet or created by user Event Listeners. Communication request-response can be estabilished for cluster to cluster connection or via whole clusters network in broadcast mode. Every Skynet cluster is sender (server) and responder (client) at once.

In code, those 2 objects are available as:

-------- PHP code --------use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();-------- !PHP code --------
and
-------- PHP code --------use Skynet\Data\SkynetResponse;
$response = new SkynetResponse();-------- !PHP code --------

In Event Listeners by easy to use:

-------- PHP code --------$this->request-------- !PHP code --------
and
-------- PHP code --------$this->response-------- !PHP code --------

Every Event Listener has access to them and can manipulate sended/received via those objects data.


### 3.1. RequestRequest object creates, parses and manipulates on sending to another cluster data. This object offers easy access to all fields sending to another clusters. Every of those fields are params with pairs "key:value" whitch can be receive by another cluster and assigned to their request object. Skynet has some default built-in Event Listeners works on requesting and requested data and you can easily create your own listeners. By the way, this is an idea of Skynet - to create listeners and work with them under framework.

Look at an example:
Code below creates new request object and sets field called 'foo' with value 'bar':
-------- PHP code --------
use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$request->set('foo', 'bar');
-------- !PHP code --------

Code below will receive value of field 'foo' from request object:
-------- PHP code --------
$foo = $request->get('foo');
-------- !PHP code --------

This is the simpliest usage and it's operates on one single [i]key:value[/i]request field.
With Skynet you can create more specified fields as arrays of params. Code below creates an array of two parameters in single request:

-------- PHP code --------
use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$request->set('foo', array('key1' => 'bar1', 'key2' => 'bar2'));
-------- !PHP code --------

At next, you can receive array like that by:
-------- PHP code --------
$foo = $request->get('foo');
$key1 = $foo['key1'];
$key2 = $foo['key2'];
-------- !PHP code --------

If a request field is not set then:

-------- PHP code --------
$foo = $request->get('FIELD_KEY');
-------- !PHP code --------

always returns NULL, so you can use this to check if any field exists in request, like below:

-------- PHP code --------
if($request->get('FIELD_KEY') !== null)
{
  /* do something */
}
-------- !PHP code --------

Code above sets single parameter (imagine that this is a single variable) whitch will be send to clusters, but you will also use Skynet to sending commands (they are documented in next sections).
Commands can take more that one parameter per command, e.g. if you using command @opt_set then you can specifiy more that one field to one command.
Take a look at example:

-------- PHP code --------
use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$request->set('@reg_set', array('key1' => 'bar1', 'key2' => 'bar2');
-------- !PHP code --------

And now:

-------- PHP code --------key1:bar1 and key2:bar2-------- !PHP code --------

are still a single parameter. So, with Skynet you can send more parameter where every parameter is an array, let's see an example:

-------- PHP code --------
use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$param1 = array('key1' => 'bar1', 'key2' => 'bar2');
$param2 = array('key3' => 'bar3', 'key4' => 'bar4');
$request->set('@reg_set', array($param1, $param2);
-------- !PHP code --------

Every parametr can be set from 3 different ways:

- in PHP code (as above)
- via webconsole
- via CLI mode

Code above is equals to setting parameters from webconsole, e.g.:

-------- PHP code --------key1:value1, key2:value2-------- !PHP code --------

and equals to the same in CLI mode:

-------- PHP code --------php skynet.php -send "key1:value1, key2:value2"-------- !PHP code --------

The Request object works in 2 ways:

- on "sender" side you are using request object to create request witch will be send to other clusters
- on "receiver" side cluster receives request from sender and operates on sended data by own request object just like above.

So, if you sets a field called foo on sender cluster:

-------- PHP code --------
use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$request->set('foo', 'bar');
-------- !PHP code --------

After send this request to receiver then receiver will be have access to field foo by own request object:

-------- PHP code --------
use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$foo = $request->get('foo');
-------- !PHP code --------

You will see more about using Request in Event Listeners section.
At this time you should know that in Event Listeners you have simpliest access to request object by:

-------- PHP code --------$this->request-------- !PHP code --------

When request is prepared (it can have lot of fields, above we are only sending one for an example) then you can send request to one specified cluster or whole clusters network.


### 3.2. ResponseResponse objects creates and manipulates on response for received requests. After cluster receives request from another cluster response object creates and prepares response depends on received in request parameters or commands.
When preparing response for request Skynet launch Events Listeners whitch can add their own fields to response. Returned by response fields are received by request sender and available in its own response object.

In code, the response object is creating this way:

-------- PHP code --------
use Skynet\Data\SkynetResponse;
$response = new SkynetResponse();
-------- !PHP code --------

Look at an example:
Code below creates new response object and fills field called 'foo' with value 'bar':
-------- PHP code --------
use Skynet\Data\SkynetResponse;
$response = new SkynetResponse();
$response->set('foo', 'bar');
-------- !PHP code --------

Code below will receive value of field 'foo' from response:
-------- PHP code --------
$foo = $response->get('foo');
-------- !PHP code --------

Let's see how it works:
Sender cluster sends a prepared request to another cluster sending field 'foo' to it:

On request sender cluster side:
-------- PHP code --------use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$request->set('foo', 'bar');
-------- !PHP code --------

Request above is sending to receiver cluster, at next the receiver cluster gets field 'foo' from own request object.

On request receiver side:
-------- PHP code --------use Skynet\Data\SkynetRequest;
$request = new SkynetRequest();
$foo = $request->get('foo');
-------- !PHP code --------

And now, the receiver can prepare response for this request, e.g.:

On request receiver (and response sender) side:
-------- PHP code --------use Skynet\Data\SkynetRequest;
use Skynet\Data\SkynetResponse;

$request = new SkynetRequest();
$response = new SkynetResponse();

if($request->get('foo') == 'bar')
{
  $response->set('bar', 'foo');
}
-------- !PHP code --------

At next, response is received by request sender and request sender have access to this response by own response object:

On request sender (and response receiver) side:
-------- PHP code --------use Skynet\Data\SkynetResponse;
$response = new SkynetResponse();

if($response->get('bar') == 'foo')
{
  /* do something */
}
-------- !PHP code --------

The Response object works in 2 ways:

- on "receiver" side cluster generates response for request from sender cluster
- on "sender" side response is received and request sender can get data from this request received from response sender via own response object

In Event Listeners you will be using response object via:

-------- PHP code --------$this->response-------- !PHP code --------

Response is preparing once when request arrives and response for it is generated.
You can generate response only from code via Event Listeners.


### 4. FeaturesSkynet has lot of features. In this section you will read about most important of them.


### 4.1. Send/receive parametersMost basic (but most important) feature is remote sending and receiving parameters by request and response objects - everything in Skynet is controlled by this.
With Skynet you can setting single parameters like:

[foo:bar]

or more complicated data, like arrays:

[foo:bar1, bar2, bar3]

All parameters sending and receiving by Skynet are encrypted by default. You can disable data encryption in config file (not recommended) or implements you own algorythms for encryption (at default only simple base64 is included). All of parameters are sending by one single request (or response) - Skynet is packing them into one packet. How it works?

You can set paameters by three different ways:

- from PHP code via Event Listeners
- from webconsole
- from CLI

## Sending parameters from Event Listener: 
Let's imagine that we have 2 clusters: [i]skynet1.php[/i] and [i]skynet2.php[/i] and [i]skynet1.php[/i] must send information about [i]foo[/i] to [i]skynet2.php[/i].
To do this, [i]skynet1.php[/i] must prepare request to be send, sets parameter (field) and assign to them value with time and sends prepared request to [i]skynet2.php[/i]
Skynet use special classes called Event Listeners for operating on requesting and receiving data, so all we need to do is to assign our parameter [i]foo[/i] to event:

-------- PHP code --------
onRequest()
-------- !PHP code --------

This event is launches two times on both sides - when request is creating (on sender cluster) and when request is received (on receiver). As you see, every event is fired 2 times in 2 different context - as sender and as a receiver.

This two contexts are named in Skynet as:

- beforeSend
- afterReceive

Information about actual context is getting as argument in every event.
Depends on this information you can prepare code for 'sender side' and for 'receiver side'.

To prepare request (on sender cluster) with our parameter [i]foo[/i] we must use context "beforeSend", becose this context is used when request is under preparation.

skynet1.php:
-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('foo', 'bar');
  }
}
-------- !PHP code --------

That's it. We creates new parameter (field) called [i]foo[/i] and set this to [i]bar[/i].
Request will be send when Skynet will be broadcasting another clusters (or via single connection if you specify it). Sended parameter will be available on receiver cluster request object from context [i]afterReceive[/i]:

skynet2.php:
-------- PHP code --------
public function onRequest($context)
{
  if($context == "afterReceive")
  {
    $foo = $this->request->get('foo');
  } 
}
-------- !PHP code --------

And now the receiver cluster can prepare response for request above. We will use for that [i]onResponse()[/i] event witch works in two context too:

skynet2.php:
-------- PHP code --------
public function onResponse($context)
{
  if($context == "beforeSend")
  {
    $foo = $this->request->get('foo');
    if($foo !== null)
    {
      $this->response->set('thanks', 'Thank you!');
    }
  } 
}
-------- !PHP code --------

That' it. Request receiver (skynet2.php) will now respond with parameter (field) [i]thanks[/i] setted to [i]Thank you![/i].
Now, when a request sender cluster (skynet1.php) receives the response, parameter [i]thanks[/i] will be available in its response object in context [i]afterReceive[/i]:

skynet1.php:
-------- PHP code --------
public function onResponse($context)
{
  if($context == "afterReceive")
  {
    $responseThanks = $this->response->get('thanks');
    if($responseThanks !== null)
    {
      /* Nice. */
    }
  } 
}
-------- !PHP code --------

If you want to specify only one cluster receiver when preparing request you should use command:

-------- PHP code --------@to-------- !PHP code --------

Example for specify skynet2.php cluster as only receiver of our request:
skynet1.php:
-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('foo', 'bar');
    $this->request->set('@to', 'http://localhost/skynet/skynet2.php');
  }
}
-------- !PHP code --------

The [@to] command specifying receiver cluster. Only this cluster will receive prepared request as above.

Another way is to send parameters via webconsole and CLI mode - those two methods are described more complexed in section "Console & CLI Mode".

## Sending parameters from webconsole: 
If you want send parameter via webconsole type:

-------- PHP code --------param:value-------- !PHP code --------

and click on "Send request".
In our case this could be, e.g.:

-------- PHP code --------foo:bar-------- !PHP code --------

To send more than one parameter via webconsole, you must set every parameter in new line and separate them by ";", e.g.:

-------- PHP code --------foo:bar; 
foo2:bar2; 
foo3:bar3-------- !PHP code --------

Then when you click on "Send request" three parameters (fields) will be send in single request.

## Sending parameters from CLI mode: 
In PHP CLI mode, when you launch Skynet this way you will need to use:

-------- PHP code --------php skynet.php -send "foo:bar; foo2:bar2"-------- !PHP code --------


### 4.2. Send/receive commandsSkynet commands are special types od parameters. They are requests for some kind of action to be executed. Commands are similar to parameters but prefixed by "@". Every parameter with name prefixed that is interpreted by Skynet as a command.
Commands can take parameter (or parameters) and can be call from PHP code (via Event Listeners) or via webconsole or command line in CLI mode.

Let's look at the example.
In previous section we was sending parameter [i]foo[/i] to [i]skynet2.php[/i] cluster. We defined receiver cluster by:

-------- PHP code --------@to-------- !PHP code --------

This parameter is one of the commands in Skynet.
With command you can send to another clusters a request to execute specified by command action, like set value in database, or launch any other action. You can define actions for received commands in Event Listeners:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "afterReceive")
  {
    if($this->request->get('@COMMAND_NAME')
    {
      /* do something */
    }
  } 
}
-------- !PHP code --------

where @COMMAND_NAME is name of command sended by:

-------- PHP code --------$this->request('set', '@COMMAND_NAME');-------- !PHP code --------

or

-------- PHP code --------@COMMAND_NAME-------- !PHP code --------

in webconsole.


Special type of commands is:

[return]

It's not called "return", but its called by single "@" char.
When parameter returned with response is prefixed by "@" and not "@<<" that is exacly the echo command. This command do nothing but returns parameters sended in request. You can disable this option (include sended data in response) in config file.

Another special type od command is "Skynet control parameter".
Those commands are prefixed by ["_skynet"] (not by "@") and controls connection params.
You should not use prefix [i]_skynet[/i] in your own defined parameters and commands becose this prefixes are reserved for Skynet internal core.

Commands can take arguments, e.g. when you're setting receiver cluster address by:

-------- PHP code --------$this->request->set('@to', 'CLUSTER_ADDRESS');-------- !PHP code --------

[i]CLUSTER_ADDRESS[/i] is here an argument of command [@to].

If you want to specify argument by webconsole, you must add it after space, e.g.:

-------- PHP code --------@to CLUSTER_ADDRESS-------- !PHP code --------
(press "Send request")

You can pass multiple arguments to some commands by separating them with coma -"[,]"  e.g.:

-------- PHP code --------
@connect CLUSTER1, CLUSTER2, CLUSTER3
-------- !PHP code --------

Usage in CLI is similar to defining parameters:

-------- PHP code --------
-send "@connect CLUSTER1, CLUSTER2, CLUSTER3"
-------- !PHP code --------

You will find full commands list in section "Skynet Commands". Of course you can (and you should) define your own commands in your own Event Listeners to extends Skynet for functionality as you need.


### 4.3. Self-updating[Event Listener:] Skynet\EventListener\SkynetEventListenerUpdater

Skynet has built-in function for remotely self-updating its own PHP source code. When you send to clusters the [@self_update] command, all clusters whitch receive this command will launch update procedure. When you are sending [@self_update] command you must specify location of skynet cluster with new code. When updating, cluster will connect with it. At next, cluster with new source code will show their code and destination clusters will read this code and replace own code with it. How it works?

Let's imagine that we have two Skynet clusters in two different locations: [i]skynet_old.php[/i] and [i]skynet_new.php[/i].

E.g.:

-------- PHP code --------http://localhost/foo/skynet_old.php-------- !PHP code --------

and 

-------- PHP code --------http://localhost/bar/skynet_new.php-------- !PHP code --------


When [i]skynet_old.php[/i] is your old file with some code and [i]skynet_new.php[/i] is the newest compiled version (e.g. with new functions whitch you build-in) you can send request to all old clusters from this new one (or from another cluster). Example: if you'll send [@self_update] command from [i]skynet_new.php[/i] to remotely placed [i]skynet_old.php[/i] and specify [i]skynet_new.php[/i] as source for updating procedure then [i]skynet_old.php[/i] will connect with [i]skynet_new.php[/i] and ask it for show its own code. At next, [i]skynet_new.php[/i] will show it own source code and old cluster will get this. Finally, [i]skynet_old.php[/i] will replace own code with this new one. Of course, you can send [@self_update] command to more than one cluster at once. If you do this then all older clusters will update with new one. You can do this, even if other clusters are on different servers with this one command: [@self_update].

When sending [@self_update] command you need specify address to cluster witch is source with new PHP code. After updating, clusters whitch was updated will response with update result: 
You will see parameters in response:

-------- PHP code --------@<<self_update_success-------- !PHP code --------

or if any errors occurs:

-------- PHP code --------@<<self_update_error-------- !PHP code --------

with update procedure results.

## Parameters: 
[source] - source address to cluster with new code

## Usage: (PHP code) 

You can send [@self_update] command from event listener:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@self_update', array('source' => 'ADDRESS_TO_SOURCE_CLUSTER'));
  }
}
-------- !PHP code --------

When [i]ADDRESS_TO_SOURCE_CLUSTER[/i] is address to cluster with new code, in our case this is:

-------- PHP code --------http://localhost/bar/skynet_new.php-------- !PHP code --------

So, command above will update all clusters with code of this one.
By default, command sended like that will be send to all clusters, e.g.:

-------- PHP code --------http://localhost/foo/skynet_old.php-------- !PHP code --------
-------- PHP code --------http://localhost/foo2/skynet_old.php-------- !PHP code --------
-------- PHP code --------http://localhost/foo3/skynet_old.php-------- !PHP code --------
-------- PHP code --------http://localhost/foo4/skynet_old.php-------- !PHP code --------

If you need to update only one specified cluster you must use [@to] command, e.g.:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@self_update', array('source' => 'ADDRESS_TO_SOURCE_CLUSTER'));
    $this->request->set('@to', 'ADDRESS_TO_OLD_CLUSTER');
  }
}
-------- !PHP code --------

When [i]ADDRESS_TO_OLD_CLUSTER[/i] is an address to cluster you want to update.

## Usage: (webconsole) 

-------- PHP code --------
@self_update source:ADDRESS_TO_SOURCE_CLUSTER
-------- !PHP code --------

Command specified like that will send request to all clusters.
To specify one cluster as a receiver you add [@to] command:

-------- PHP code --------
@self_update source:ADDRESS_TO_SOURCE_CLUSTER;
@to ADDRESS_TO_OLD_CLUSTER;
-------- !PHP code --------

## Usage: (CLI mode) 

-------- PHP code --------php skynet_new.php -send "@self_update source:ADDRESS_TO_SOURCE_CLUSTER"-------- !PHP code --------

or

-------- PHP code --------php skynet_new.php -send "@self_update source:ADDRESS_TO_SOURCE_CLUSTER; @to ADDRESS_TO_OLD_CLUSTER"-------- !PHP code --------


All updates results are put logs into database and text logs (if enabled).
You can see this logs in [DATABASE VIEW] and in your logs folder.
After update procedure all clusters will have THE SAME source code as source.

Self-update procedure is executes on destination clusters in [onResponse (beforeSend)] event.

[BE CAREFUL WHEN UPDATING:] If you accidentally send wrong source or source with errors it is possible to loose connection with clusters. Update only with fully stable and tested compilations.


### 4.4. Self-cloning[Event Listener:] Skynet\EventListener\SkynetEventListenerCloner
Self-cloning is functionality whitch allow Skynet to clone itself to another locations. By default this option is disabled in config - if you want to use this you must enable it in your config file. 

Configuation file is placed in:
-------- PHP code --------/src/SkynetUser/SkynetConfig.php-------- !PHP code --------

If you want to enable [i]clone[/i] function just set to TRUE option below:

'core_cloner' => false,


When @clone command is sent to clusters then every cluster will try to scan all subdirectories where cluster is placed and try to copy to them. After that (if successed) - clusters will broadcast information about new clones on the network to register new ones by other clusters.

At first, you should test this option by localhost.
Just create directory (and subdirectories in it) when cluster is placed. After that, launch your cluster with command:

-------- PHP code --------@clone me-------- !PHP code --------

Just type command above in webconsole and 'Send Request'.
Your cluster should be cloned into all directories in its location, and at next - a new clones should be cloned itselfs into next subdirectiories, and so one...

To remotely send @clone command to other clusters, type in webconsole:

-------- PHP code --------
@clone CLUSTER_ADDRESS
-------- !PHP code --------

or

-------- PHP code --------
@clone CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...
-------- !PHP code --------

or with argument "all" (or without any arguments) to send command to all clusters.
In Skynet every command typed without parameters is sending to all clusters by default.

Analogously, you can send command in Event Listener:
-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@clone', 'all');   
  }
}
-------- !PHP code --------

[Be careful with using this option, becase if you call @clone then Skynet will replicate to ALL directories where it placed.]


### 4.5. Sending emails[Event Listener:] Skynet\EventListener\SkynetEventListenerEmailer
Skynet has built-it method for sending responses from clusters to specified email address by using PHP's sendmail. When sending emails option is enabled then email is sending every time when response is created on server that create response (or if response is generated from code and e.g. launching from CRON). By default, there is no specified email address of receiver in config file (default address is set) - you must specify email address itself in:

-------- PHP code --------/src/SkynetUser/SkynetConfig.php-------- !PHP code --------

by placing new email address against:

-------- PHP code --------'emailer_email_address' => 'your@email.com',-------- !PHP code --------

After that, if an email address is specified you must enable sending emails on cluster. You can do this by setting Skynet registry option [i]email[/i] to value [i]1[/i].

To enable sendmail option on cluster, type in webconsole:

-------- PHP code --------
@opt_set email:1
-------- !PHP code --------

This will enable email sending for all clusters in network.
If you want to enable option only on specified cluster you must mixed this option with command @to, like that:

-------- PHP code --------
@opt_set email:1;
@to CLUSTER_ADDRESS
-------- !PHP code --------
(remember about separate commands with coma ";" and press "Send request")

To disable email sending set option to [i]0[/i].

Sended emails are also logged in database and text logs (if enabled).


### 4.6. Logging events[Loggers are offered from:] Skynet\EventLogger
Skynet has complex logging system. It stores events logs (includes requests, responses and more) in two different places - as text files on server and in database. 
By default, both of these options are enabled but you can disable/or enable them into your config file.

Text files logs are stored in specified in config file location (default is: [i]/logs[/i]).
In database, you will see all of your stored data by switching your [View Mode] in [i]Skynet Control Panel[/i] to [i]Database View[/i].

Records with logs can be removed by clicking on [i]Delete[/i] button or you can erasing all records by one click via [i]Delete all[/i] button. 

You can easy generate txt files from specified records by clicking on [i]Generate TXT[/i] button on record.

Loggers are based on factory design so you can create your own logging system and register this into Skynet.
Every event log can by configured in config file. You can create your own logging system also and append it to the factory.

[NOTE: Remember that every event is logged so your logs directory may includes lot of files after longer time. You should delete old, unused logs every once in a while.]


### 4.7. BroadcastingSkynet can work in two different modes: as single connection cluster-cluster or in broadcast mode (peer-to-peer). When Skynet is in brodacast mode all of clusters are broadcasted every time when Skynet is launches. 

By default, every cluster starts by code below:

-------- PHP code --------
$skynet = new Skynet(true);
$service = new SkynetResponder(true);
-------- !PHP code --------

in

-------- PHP code --------SkynetLauncher()-------- !PHP code --------

Parameter TRUE in [i]Skynet()[/i] constructor starts broadcast mode and renders output (setting this to FALSE will not starts broadcast automaticaly). If you set this to FALSE then you can launch broadcast mode manualy by:

-------- PHP code --------$skynet->broadcast();-------- !PHP code --------

And to enable output:

-------- PHP code --------echo $skynet->renderOutput();-------- !PHP code --------

or simply:

-------- PHP code --------echo $skynet;-------- !PHP code --------


Parameter TRUE in [i]SkynetResponder()[/i] constructor launch responder (setting this to FALSE will disable responding by Skynet).


## Extended broadcast (resending requests) 
[Event Listener:] Skynet\EventListener\SkynetEventListenerEcho
When Skynet is in broadcast mode then every cluster is requested at start. But notice that when sending requests that requests are sending only to clusters (stored in database) once and the response is returned once only to sender also. 
What now if you want to resend responses and requests to another clusters? You will need to use [@broadcast] command.

This command tells Skynet to resend requests and responses to next clusters.

[Example:]

In normal broadcast the first cluster sends to other clusters request with parameter:

-------- PHP code --------foo:bar-------- !PHP code --------

Every cluster responds for this by returning response to first cluster (witch was send request). 
And that's finish. Nothing more will happend.

In extended broadcast mode (when [@broadcast] command is used) request will be resend to the next clusters by other clusters. 
In this case, when you send request with [i]foo:bar[/i] to cluster number 2, then cluster number 2 will connect with cluster 3, 4, 5... and send them exacly the same request (with [i]foo:bar[/i]).

To enable extended broadcast mode, type in webconsole:

-------- PHP code --------@broadcast-------- !PHP code --------

or in Event Listener:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@broadcast', '1');
  }
}
-------- !PHP code --------

[Note:] with extended broadcast you can create more complexed, chained actions, like resending requests decorated by data received from other cluster on the way.

[Note:] when cluster receives [@broadcast] command no response is generated (it should be sended in [i]onBroadcast()[/i], not in [i]onResponse()[/i] event if needed).


### 4.8. Sleep and Wakeup[Event Listener:] Skynet\EventListener\SkynetEventListenerSleeper
Every cluster can be remotely "sleeped". Sleeped clusters are not broadcasting and they not generate responses.

If you want to sleep specified cluster, type in webconsole:

-------- PHP code --------@sleep CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@sleep CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------

If you want to sleep your own cluster, type:

-------- PHP code --------@sleep me-------- !PHP code --------

In Event Listener you will do it with:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@sleep', '1');
  }
}
-------- !PHP code --------

Alternatively, you can sleep cluster via setting option:

-------- PHP code --------@opt_set sleep:1-------- !PHP code --------

In Event Listener (it will work only for THIS cluster):

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->opt_set('sleep', 1);
  }
}
-------- !PHP code --------

When sleep, you can restore cluster by wake up it.
To wakeup cluster just use:

-------- PHP code --------@wakeup CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@wakeup CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------
to wakeup remote cluster.

OR:

-------- PHP code --------@wakeup me-------- !PHP code --------

if you want to wake up your own cluster.

Alternatively, you can wakeup cluster by setting option [i]sleep[/i] to [i]0[/i]:

-------- PHP code --------@opt_set sleep:0-------- !PHP code --------


### 4.9. File transfer[Event Listener:] Skynet\EventListener\SkynetEventListenerFiles

Skynet can gets and writes remote files via one command. You can open any file (if you have correct privilleges) on remote server where Skynet cluster is placed, read its data and get this data in response. You can also put remote file by sending request and defining data to save.

To read remote file from server where Skynet cluster is placed use command:

-------- PHP code --------@fget-------- !PHP code --------

This command takes one parameter:

-------- PHP code --------path:PATH_TO_FILE-------- !PHP code --------


By example, after Skynet cluster receives request:

-------- PHP code --------@fget path:file.txt-------- !PHP code --------

(via PHP code):

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@fget', array('path' => 'file.txt'));
  }
}
-------- !PHP code --------

then cluster will try to open file called [i]file.txt[/i] and read its content.
If success then content of this file will be returned in response in parameter:

-------- PHP code --------@<<fgetFile-------- !PHP code -------- 

This parameter will be have content of readed file.
This content will be also saved in [i]/_download[/i] folder where Skynet whitch sent request for is placed.

If any errors occurs (file not exists or no access) then information about it will be returned in paramterer:

-------- PHP code --------@<<fgetStatus-------- !PHP code --------

To put a file on remote server where Skynet cluster is placed use command:

-------- PHP code --------@fput-------- !PHP code --------

This command takes two parameters:

-------- PHP code --------path:PATH_TO_FILE, data:DATA_TO_SAVE-------- !PHP code --------

By example, if you want put file [i]file.txt[/i] with data [i]some_text[/i] just use a command:

-------- PHP code --------@fput path:file.txt,data:some_text-------- !PHP code --------

or via PHP code:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@fput', array('path' => 'file.txt', 'data' => 'some_text'));
  }
}
-------- !PHP code --------

Result of file saving will be returned in response in field:

-------- PHP code --------@<<fputStatus-------- !PHP code --------

To delete remote file use command:

-------- PHP code --------@fdel path:PATH_TO_FILE-------- !PHP code --------


### 4.10. Remote system shell execution[Event Listener:] Skynet\EventListener\SkynetEventListenerExec
Skynet allows you to remote shell execution. You can launch shell command (or other application) on remote and Skynet will returns output of it. Note that this option should not be used for nonauthorized operations. Skynet offers 3 different ways to remote shell execution. All of them are based on PHP shell function but they are small different. By sending one parameter you can remotely opens shell execute command and Skynet will return output of the shell execution in response object.

First command for remote shell execution is:

-------- PHP code --------@exec-------- !PHP code --------

This is based on PHP [i]exec()[/i] function, it takes one argument whitch is command to be executed on remote shell.
Argument with command to execute must be set in cmd parameter.

Example of usage (PHP code):

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@exec', array('cmd' => 'COMMAND_TO_EXECUTE'));
  }
}
-------- !PHP code --------

Example of usage (webconsole):

-------- PHP code --------@exec cmd:COMMAND_TO_EXECUTE-------- !PHP code --------

Skynet will remotely open system shell (via [i]exec()[/i] function), execute [i]COMMAND_TO_EXECUTE[/i] and return output via 3 parameters in response:

-------- PHP code --------@<<execResult ($result)-------- !PHP code --------
-------- PHP code --------@<<execReturn ($return)-------- !PHP code --------
-------- PHP code --------@<<execOutput ($output)-------- !PHP code --------

Whitch are output of:

-------- PHP code --------$result = exec($cmd, $output, $return);-------- !PHP code --------


## Example: 
If you want execute command [i]whoami[/i] on remote linux or Windows system, just use:

-------- PHP code --------@exec cmd:whoami-------- !PHP code --------

or in PHP code:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@exec', array('cmd' => 'whoami'));
  }
}
-------- !PHP code --------

Output of remote execution of command [i]whoami[/i] (user name) will be return in response.

Another command is:

-------- PHP code --------@system-------- !PHP code --------

This is based on PHP [i]system()[/i] function, it takes one argument whitch is command to be executed on remote shell.
Like above, argument with command to execute must be set in [i]cmd[/i] parameter.

This command executes remotely:

-------- PHP code --------$result = system($cmd, $return);-------- !PHP code --------

And returns in response:

-------- PHP code --------@<<execResult ($result)-------- !PHP code --------
-------- PHP code --------@<<execReturn ($return)-------- !PHP code --------

Like above if you want to execute [i]whoami[/i] just use:

-------- PHP code --------@systen cmd:whoami-------- !PHP code --------

or in PHP code:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@system', array('cmd' => 'whoami'));
  }
}
-------- !PHP code --------

Last command is a little bit complicated and it's based on PHP's:

-------- PHP code --------proc_open()-------- !PHP code --------

In Skynet, when you use command:

-------- PHP code --------@proc-------- !PHP code --------

It will remotely execute [i]proc_open()[/i] function with passed process name as first argument.

Usage of [@proc] is different than two previous commands.
Process you want to open needs to be passed by [i]proc[/i] argument:

-------- PHP code --------@proc proc:PROCESS_NAME-------- !PHP code --------

or in PHP code:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->request->set('@proc', array('proc' => 'PROCESS_NAME'));
  }
}
-------- !PHP code --------

Skynet will return output like before but here you can manipulate process [i]pipes[/i]

At this time you must do this manualy, by editing listener or creating your own.
By default, [i]proc_open()[/i] runs under configuration as below:

-------- PHP code --------
$descriptorspec = array(
    0 => array('pipe', 'r'), 
    1 => array('pipe', 'w'), 
    2 => array('pipe', 'w') 
);

$process = proc_open($proc, $descriptorspec, $pipes);

if(is_resource($process)) 
{   
  $result = stream_get_contents($pipes[1]);
  fclose($pipes[0]);
  fclose($pipes[1]);   
  fclose($pipes[2]);
  $return = proc_close($process);
}
-------- !PHP code --------

where [i]$proc[/i] is process name passed remotely from request and [i]$return[/i] is always returned in response via [@<<procReturn] parameter.


### 4.11. Remote PHP code execution[Event Listener:] Skynet\EventListener\SkynetEventListenerEval

Skynet offers remote PHP code execution functionality. It's based on PHP's [i]eval()[/i] function.
If you need to execute PHP code sended via request on remote cluster(s) just use:

-------- PHP code --------@eval-------- !PHP code --------

Command takes one parameter: [i]php[/i] with code source.

Example:

If you want to execute code below on another cluster and takes result:

-------- PHP code --------<?php return 2+2; ?>-------- !PHP code --------

you need to do this like these:

-------- PHP code --------@eval php:2+2;-------- !PHP code --------

or in Event Listener:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $code = '2 + 2;';
    $this->request->set('@eval', array('php' => $code));
  }
}
-------- !PHP code --------

Skynet will send request, remotely execute PHP code and returns output in response field:

-------- PHP code --------@<<eval-------- !PHP code --------


### 4.12. RegistrySkynet offers database registry to quick and easy store any data. Data in registry is stored by key-value pairs structure and every Event Listener has access to this registry. 
You can use registry to store any data, after that you can send this data via request or use it stored data in response.

To store any value in registry use command:

-------- PHP code --------@reg_set foo:bar-------- !PHP code --------

where [i]foo[/i] is the key, and [i]bar[/i] is the value

To receive stored registry value from remote cluster, use:

-------- PHP code --------@reg_get foo-------- !PHP code --------

After request will be sent, value of the key [i]foo[/i] will be returned in response.

You can store multiple values at once, by separating them by coma ",". 

## Examples: 

-------- PHP code --------@reg_set foo:bar, foo2:bar2, foo3:bar3-------- !PHP code --------

-------- PHP code --------@reg_get foo, foo2-------- !PHP code --------

To store value in cluster's own registry, use this code in event listener:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $this->reg_set('foo', 'bar');
  }
}
-------- !PHP code --------

To get value from registry use:

-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
    $foo = $this->reg_get('foo');
  }
}
-------- !PHP code --------

Of course, you can use all of this in every event, not only in onRequest().

If you want to set/ or get values from specified clusters you must mix request with @to command:

-------- PHP code --------
@reg_set foo:bar;
@to CLUSTER_ADDRESS
-------- !PHP code --------


### 4.13. Echo/Ping[Event Listener:] Skynet\EventListener\SkynetEventListenerEcho
Echo command sends to all clusters a request for another echo (ping). When clusters receives [@echo] command then they will send ping to another clusters stored in database. You can use this command to update clusters lists (when sending echo, clusters list from database is included in request as a clusters chain).

To send [@echo] command just type:

-------- PHP code --------@echo-------- !PHP code --------

This will send command to all clusters in network.

Echo command (and [@broadcast] command) are use special object called [SkynetPeer]. This object allows to create other connection when cluster is already connected with other (different) cluster. 
In simply words - this is "connection in connection". You can read about [SkynetPeer] in next section.

[Note:] when [@echo] was sent then no response is generated (response connection is generating by [i]Peer[/i]).

To execute code in Event Listener when [@echo] is received you should use [i]onEcho()[/i] event instead of [i]onResponse()[/i].


### 4.14. SkynetPeerSkynetPeer is a special object that can opens another connection when Skynet requesting or responding to another cluster. You can use [SkynetPeer] to connect with any other cluster in every event in any situation.

By example, let's imagine that cluster number 2 already responding to cluster number 1, and [i]onResponse()[/i] event is fired in cluster 2:

-------- PHP code --------
public function onResponse($context)
{
  if($context == "beforeSend")
  {
    /* response to cluster 1 is creating here */
  } 
}
-------- !PHP code --------

As you see, at this moment response for request from cluster 1 is generating.
But what if you want to connect here with another cluster and send request to it? You should use [SkynetPeer].

## Example: 

cluster number 2:
-------- PHP code --------
use Skynet\Core\SkynetPeer;
use Skynet\Data\SkynetRequest;
public function onResponse($context)
{
  if($context == "beforeSend")
  {
    /* response to cluster one is creating here */
    $skynetPeer = new SkynetPeer();
    $newRequest = new SkynetRequest();
    $newRequest->set('foo', 'bar');
    $skynetPeer->assignRequest($newRequest);
    $skynetPeer->connect('CLUSTER_THREE_ADDRESS');
  } 
}
-------- !PHP code --------
In code above we are creating response to cluster number 1.
In that response [SkynetPeer] was created, new request was created and the request was sent to cluster number 3.

With this method you can connect with cluster three even when you are actually responding to cluster one.
Note that you can also assign actual [$request] to [SkynetPeer] instead of creating new one:

-------- PHP code --------$skynetPeer->assignRequest($this->request);-------- !PHP code --------

Code above will assign actual [$request] (received from cluster 1) and resend this request to cluster 3.


### 5. Event ListenersSkynet's architecture is based on objects called Event Listeners. They are most important part of every cluster business logic. An idea is that every functionality of cluster is served by appropriate Event Listener. Those listeners are fired when Skynet launchs event like response to request, or request generation/send. Depends on event, listeners functions are called. With Skynet you have some default Event Listeners but the idea is that you will create new ones, depend on your needs.

Example:
When Skynet preparing response to request, event [i]onResponse()[/i] is called:

-------- PHP code --------
public function onResponse($context)
{
  if($context == "afterReceive")
  {
    /* some code here */
  } 
}
-------- !PHP code --------

Skynet executes then all of the code placed in this method called [i]onResponse()[/i].
As argument to this method Skynet is sending [i]$context[/i]. This argument pass two possible states:

- afterReceive - when response/or request is received
- beforeSend - when response/or request is preparing

With example - when Skynet preparing request, an [i]onRequest()[/i] event will be called and [i]$context[/i] will be set to 'beforeSend'. 
From other side - when cluster is creating response, then [i]onResponse()[/i] with the same context will be called. By mixing these two things (event name and event context) you can build your logic easy.

At default, with Skynet you get some Event Listeners, like Emailer, Cloner, Registry, Echo and more. Every of them doing different things. All of listeners must be registered in [i]EventListenersFactory[/i]. 
When they are registered, then all of them will be called one by one when event occured.

In every Event Listener you have access to specialy prepared API methods and objects like [i]$response[/i], [i]$request[/i] and more.

[EventLoggers] are special types of Event Listeners. They are called at the end of code execution, when all normal Event Listeners was finished their jobs. 
They are used for logging data like storing data and results from all Event Listeners launches before.



### 5.1. Event: onConnectEvent is calling just after connection to another cluster was opened. It passes [i]connector object[/i] whitch is instance of [i]SkynetConnectionInterface[/i] as an argument. With this event you can get raw encrypted data (response) from connection.

-------- PHP code --------
public function onConnect($conn = null)  
{   
  /* code executed after connection to cluster */  
}
-------- !PHP code --------

To get raw data from connection use:
-------- PHP code --------
public function onConnect($conn = null)  
{   
  $rawData = $conn->getData(); 
}
-------- !PHP code --------

To get address of connection:
-------- PHP code --------
public function onConnect($conn = null)  
{   
  $address = $conn->getUrl(); 
}
-------- !PHP code --------

More available API methods you will find in API Documentation.


### 5.2. Event: onRequestThis event is calling two times - when request data is preparing for send and after receiver cluster receives request from sender cluster. 
Depends on these two situations an argument with situation context is passed.

In first situation, when request is preparing to be send, sender will call code below:

Request sender cluster:
-------- PHP code --------
public function onRequest($context)
{
  if($context == "beforeSend")
  {
   /* code executes in sender when request is preparing to be send */
  } 
}
-------- !PHP code --------

Everything you will assign to request object above will be included in sended request.

In second situation, when request is received by cluster code below is executed:

Request receiver cluster:
-------- PHP code --------
public function onRequest($context)
{
  if($context == "afterReceive")
  {
   /* code executes in responder when responder gets request from sender */
  } 
}
-------- !PHP code --------
In code above you have access to whole received request via:

-------- PHP code --------$this->request-------- !PHP code --------


### 5.3. Event: onResponseSimilary to [i]onRequest[/i] event, this event is calling also two times - when response data is preparing and after sender cluster receives response to request. 
Depends on these two situations an argument with context is passed.

In first situation, when response is preparing to be send, request receiver will call code below:
-------- PHP code --------
public function onResponse($context)
{
  if($context == "beforeSend")
  {
   /* code executes in responder when response is preparing to be send */
  } 
}
-------- !PHP code --------

Everything you assign to response object above will be included in sended response.

In second situation, when response is received by sender cluster code below is executed:
-------- PHP code --------
public function onResponse($context)
{
  if($context == "afterReceive")
  {
   /* code executes in sender when sender receives response */
  } 
}
-------- !PHP code --------
In code above you are have access to whole received response via:

-------- PHP code --------$this->response-------- !PHP code --------


### 5.4. Event: onEchoEvent is calling two times - when response data is preparing for send and after sender cluster receives response. 
Depends on these two situations an argument with context is passed.

In first situation, when response is preparing to be send, receiver will call code below:
-------- PHP code --------
public function onEcho($context)
{
  if($context == "beforeSend")
  {
   /* code executes in responder when response is preparing to be send */
  } 
}
-------- !PHP code --------

Everything you assign to response object above will NOT be send.
Response in echo mode is not returned. You can send data from here via only from [SkynetPeer].

In second situation, when response is received by sender code below is executed:
-------- PHP code --------
public function onEcho($context)
{
  if($context == "afterReceive")
  {
   /* code executes in sender when sender receives response */
  } 
}
-------- !PHP code --------
In code above response will be empty.


### 5.5. Event: onBroadcastEvent is calling two times - when response data is preparing for send and after sender cluster receives response. 
Depends on these two situations an argument with context is passed.

In first situation, when response is preparing to be send, receiver will call code below:
-------- PHP code --------
public function onBroadcast($context)
{
  if($context == "beforeSend")
  {
   /* code executes in responder when response is preparing to be send */
  } 
}
-------- !PHP code --------

Everything you assign to response object above will be included in sended response.
In extended broadcast mode also request will be included to response here.

In second situation, when response is received by sender code below is executed:
-------- PHP code --------
public function onBroadcast($context)
{
  if($context == "afterReceive")
  {
   /* code executes in sender when sender receives response */
  } 
}
-------- !PHP code --------
In code above you have access to whole received response via:
-------- PHP code --------$this->response-------- !PHP code --------


### 5.6. Event: onConsoleThis event is called when Skynet starts (before any connections) when webconsole input commands are passed. You can place here code whitch must be executed when user type defined command or parameter.
In event you have access to console object so you can get all parameters and commands.

Access to console is offered by object:

-------- PHP code --------$this->console-------- !PHP code --------

Take a look at example:

-------- PHP code --------
public function onConsole()
{
  if($this->console->isConsoleCommand('foo'))
  {
     /* do something */
  }
}
-------- !PHP code --------

Code above checks for command [i]foo[/i] exists in input.

Method [i]isConsoleCommand('COMMAND_NAME')[/i]:

-------- PHP code --------$this->console->isConsoleCommand('foo')-------- !PHP code --------

returns TRUE if there is command [i]@foo[/i] typed in console.
Note that argument passed here is without @ prefix.
At next, you can depends your actions in EventListener from command existing. 

To get command data (like its params) you must use

-------- PHP code --------$this->console->getConsoleCommand('COMMAND_NAME');-------- !PHP code --------

This method returns [i]SkynetCommand[/i] object.

Every [i]SkynetCommand[/i] has two most commonly using methods:

-------- PHP code --------$command->getCode()-------- !PHP code --------

whitch returns command string name (without @ prefix)

-------- PHP code --------$command->getParams()-------- !PHP code --------

whitch returns array with params passed to command.

## Example: 

-------- PHP code --------
public function onConsole()
{
  if($this->console->isConsoleCommand('foo'))
  {
    $command = $this->console->getConsoleCommand('foo');     
    $name = $command->getCode(); // foo
    $params = $command->getParams(); // params passed to @foo     
  }
}
-------- !PHP code --------

This was about getting commands data, if you want to get parameters passed into console (like [i]foo:bar[/i]) you must get parameters list via:

-------- PHP code --------
public function onConsole()
{ 
  $params = $this->console->getConsoleRequests();   
  
  foreach($params as $paramName => $paramValue)
  {
    // some code here
  }
}
-------- !PHP code --------

## Example: 

If parameter [i]foo[/i] with value [i]bar[/i] was passed into webconsole by typing:

-------- PHP code --------foo:bar-------- !PHP code --------

then you will see this parameter in:

-------- PHP code --------
public function onConsole()
{ 
  $params = $this->console->getConsoleRequests();   
  
  foreach($params as $paramName => $paramValue)
  {
    // $paramName <<< foo
    // $paramValue <<< bar
  }
}
-------- !PHP code --------

## Return value 
Method [i]onConsole()[/i] can returns string.
If any string is returned it will be display in Console output window in Skynet Control Panel.

## Example: 

-------- PHP code --------
public function onConsole()
{
  if($this->console->isConsoleCommand('foo'))
  {
    return 'Command foo is passed';
  }
}
-------- !PHP code --------


### 5.7. Event: onCliThis event is calling only when Skynet starts from CLI mode and when input commands are passed. You can place here code whitch must be executed when user type defined command or parameter.
In event you have access to CLI object so you can get all parameters and commands.

Access to CLI commands is offered by object:

-------- PHP code --------$this->cli-------- !PHP code --------

Take a look at example:

-------- PHP code --------
public function onCli()
{
  if($this->cli->isCommand('foo'))
  {
     /* do something */
  }
}
-------- !PHP code --------

Code above checks for command [i]foo[/i] exists in CLI input.

Method [i]isCommand('COMMAND_NAME')[/i]:

-------- PHP code --------$this->cli->isCommand('foo')-------- !PHP code --------

returns TRUE if there is command [i]@foo[/i] typed in CLI console.
Note that argument passed here is without "-" prefix.

Access to specified command parameters is offered by method:

-------- PHP code --------$this->cli->getParams('foo')-------- !PHP code --------

It returns array with passed arguments.
If a command gets only one argument you can access it by:

-------- PHP code --------$this->cli->getParam('foo')-------- !PHP code --------

## Example 
If you want check for command [i]-foo[/i] passed by CLI mode and it params, e.g.:

-------- PHP code --------php skynet.php -foo param1 param2-------- !PHP code --------

You will need to do this like this:

-------- PHP code --------
public function onCli()
{
  if($this->cli->isCommand('foo'))
  {
     $params = $this->cli->getParams('foo');
     foreach($params as $param)
     {
       /* some code here */     
     }
  }
}
-------- !PHP code --------

If method [i]onCli()[/i] returns any string then this string will be displayed in CLI mode.

Example:

-------- PHP code --------
public function onCli()
{
  if($this->cli->isCommand('foo'))
  {
     /* do something */
     return 'Something was done.';
  }
}
-------- !PHP code --------


### 5.8. registerCommandsThis is a special method whitch allows you to register your own commands from Event Listener. You can create commands for webconsole and for CLI mode.
This method is calling at Skynet start and all of available in webconsole select list commands and commands whitch are displayed in CLI when you viewing help are defined here.

In this method you must define two arrays:

-------- PHP code --------$cli = [];-------- !PHP code --------
-------- PHP code --------$console = [];-------- !PHP code --------  

And you must return this arrays as below:

-------- PHP code --------return array('cli' => $cli, 'console' => $console);-------- !PHP code --------

In [i]$cli[/i] array you can define command for CLI mode, in $console array you can define commands for HTML webconsole.
You can create multiple commands, let's see an example:

-------- PHP code --------
$cli[] = ['-debug', '', 'Displays connections full debug'];
$cli[] = ['-dbg', '', 'Displays connections full debug (alias)'];
$cli[] = ['-cfg', '', 'Displays configuration'];
-------- !PHP code --------

Syntax is here:

-------- PHP code --------$cli[] = ['-COMMAND_NAME', 'POSSIBLE_PARAMS', 'DESCRIPTION'];-------- !PHP code --------

where [i]POSSIBLE_PARAMS[/i] can be string for single param or array for multiple params.
If [i]POSSIBLE_PARAMS[/i] are empty then params will not be shown in CLI.

When creating command for webconsole use syntax:

-------- PHP code --------$console[] = ['@COMMAND_NAME', 'POSSIBLE_PARAMS', 'DESCRIPTION'];-------- !PHP code --------

Definition is similary to [i]$cli[/i] expects prefix.

## Example: 
-------- PHP code --------
public function registerCommands()
{    
  $cli = [];
  $console = [];    
  
  $cli[] = ['-foo', '', 'bar'];
  $cli[] = ['-foo2', 'param1', 'bar2'];
  $cli[] = ['-foo3', array('param1', 'param2'), 'bar3'];    
  
  $console[] = ['@foo', '', 'bar'];
  $console[] = ['@foo2', 'param1', 'bar2'];
  $console[] = ['@foo3', array('param1', 'param2'), 'bar3'];    
  
  return array('cli' => $cli, 'console' => $console);    
}
-------- !PHP code --------


### 6. How to create own Event Listener?Custom Event Listeners should be a heart of your Skynet clusters. That's the idea what Skynet was created for - to offers easy in use architecture and API for creating event based business cluster logic. 
Let's take a look how to make own Event Listener.

By default - an empty template for your listeners is placed here:

-------- PHP code --------/src/SkynetUser/-------- !PHP code --------

It's called:

-------- PHP code --------SkynetEventListenerMyListener.php-------- !PHP code --------

When you open this file you will see empty methods for each event calling by Skynet.
This empty event listener is registered in Skynet by default, so if you place here some code it will be executed when Skynet starts.
To registering event listeners Skynet serves a factory class:

-------- PHP code --------/src/Skynet/EventListener/SkynetEventListenersFactory.php-------- !PHP code --------

In this factory you will find all listeners assigned to Skynet:

-------- PHP code --------
private function registerEventListeners()
{
  $this->register('clusters', new SkynetEventListenerClusters());
  $this->register('cloner', new SkynetEventListenerCloner());
  $this->register('console', new SkynetEventListenerConsole());    
  $this->register('options', new SkynetEventListenerOptions());
  $this->register('registry', new SkynetEventListenerRegistry());
  $this->register('my', new \SkynetUser\SkynetEventListenerMyListener());    
  $this->register('echo', new SkynetEventListenerEcho());
  $this->register('sleeper', new SkynetEventListenerSleeper());
  $this->register('updater', new SkynetEventListenerUpdater());
}
-------- !PHP code --------
As you see - your empty listener template is already registered as "my".
If you will create another listeners you would need to register them here if you want to include them in Skynet.
Notice that user defined listeners should be exists in namespace:

-------- PHP code --------\SkynetUser-------- !PHP code --------

and should be placed into directory:

-------- PHP code --------/src/SkynetUser/-------- !PHP code --------

This is for update and compile purposes.
When you will updating Skynet's core (e.g. by newest version) your custom classed will be still here in custom folder and after compiling new Skynet's core + your listeners will be included into new version of package.

OK. Let's write some code.
All events whitch you can use are described in Event Listeners sections.
Let's check how to use them and what API methods you can use in your custom listener.

## Request and response access 
In every event listener you have fully access to request and response objects:

-------- PHP code --------$this->request-------- !PHP code --------

and 

-------- PHP code --------$this->response-------- !PHP code --------

Setting and getting data from this data are served by [/i]set()[/i] and [i]get()[/i] methods.
Take a look at example:

-------- PHP code --------
public function onResponse($context)
{
  if($context == "beforeSend")
  {
    if($this->request->get('foo') == 'bar')
    {
      $this->response->set('bar', 'foo');
    }  
  } 
}
-------- !PHP code --------

That is the first method.
To get fields from both of this objects you can also use arrays:

-------- PHP code --------$this->requestsData[]-------- !PHP code --------

and 

-------- PHP code --------$this->responseData[]-------- !PHP code --------

Example:

-------- PHP code --------
public function onResponse($context)
{
  if($context == "beforeSend")
  {
    if(isset($this->requestsData['foo']) && $this->requestsData['foo'] == 'bar')
    {
      if(!isset($this->responseData['bar']))
      {
        $this->response->set('bar', 'foo');
      }
    }  
  } 
}
-------- !PHP code --------

Notice that arrays with fields are read-only and you can only getting data with this method.
If you will change any data in [i]$responseData[][/i], your operation will not be included in response - to do this you must use [i]set()[/i] method.

## Inheriting 

Every Event Listener must:

- extends [i]\Skynet\EventListener\SkynetEventListenerAbstract[/i] class
- implements [i]\Skynet\EventListener\SkynetEventListenerInterface[/i] interface

[i]SkynetEventListenerAbstract[/i] base class offers to your listener some of useful API method to use.
Most important of them are request and response objects, but there is more:

-------- PHP code --------
public function onResponse($context)
{
  if($context == "beforeSend")
  {
    $this->reg_set('foo', 'bar'); /* will set Registry field 'foo' to 'bar' */
    $foo = $this->reg_get('foo'); /* will get field 'foo' from Registry */
    
    $this->opt_set('foo', 'bar'); /* will set option 'foo' to 'bar' */
    $foo = $this->opt_get('foo'); /* will get option 'foo' from internal options */
    
    $this->auth /* Access to auth object */
    $this->db /* Access to DB PDO instance */
    $this->verifier /* Access to verifier */
    
    $this->myAddress /* address of my cluster */
  } 
}
-------- !PHP code --------

Of course, you can use more of Skynet objects, like Logger, Emailer or Console.
Full reference you will find in API Documentation.

After creating your listener you should launch Skynet compiler to compile it into cluster file. 

When you creating much more complicated files structure of your own classes (extending, implementing, etc.) remember that abstract classes files shout be named as:

-------- PHP code --------ClassNameAbstract-------- !PHP code --------

Interfaces should be named as:

-------- PHP code --------ClassNameInterface-------- !PHP code --------

Traits should be named:

-------- PHP code --------ClassNameTrait-------- !PHP code --------

This is for compilation reason - files with abstract classes, interfaces and trait are compiling at the beginning of compiled file (when you inherits from non-existing yet class PHP generates error), so remember of this.
You can create files structure as you want - it will all be compiled into standalone file. 

[Notice:] when compiling - all [i]use[/i] (expect traits use in class definition) and [i]namespace[/i] directives will be erased.


### 7. ConsoleSkynet offers by default some of useful webconsole commands.
With webconsole you can sending requests to another clusters from hand.


### 7.1. Syntax- You can send multiple fields at once, but all commands and parameters must be separated by ";" and every parameter/command must be in new line.

-------- PHP code --------
@wakeup CLUSTER_ADDRESS;
@reg_set foo:bar;
foo2:bar2;
foo3:bar3;
-------- !PHP code --------

- Setting parameters must follow syntax:

-------- PHP code --------key:value-------- !PHP code --------

or

-------- PHP code --------key1:value1, key2:value2, key3:value3-------- !PHP code --------

- Passing arguments to commands must be done after space:

-------- PHP code --------@command argument-------- !PHP code --------

or 

-------- PHP code --------@command argument1, argument2, argument3-------- !PHP code --------


- Passing [i]key:value[/i] assignments in commands must follow syntax:

-------- PHP code --------@command key:value-------- !PHP code --------

or

-------- PHP code --------@command key1:value1, key2:value2, key3:value3-------- !PHP code --------

- You can mix parameters and commands:

-------- PHP code --------
@reg_set foo:bar;
foo:bar;
@to CLUSTER_ADDRESS
-------- !PHP code --------


### 7.2. Commands list## @add 
Adds specified cluster(s) address(es) to database
-------- PHP code --------@add CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@add CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------

## @connect 
Connects with specified cluster(s) address(es)
-------- PHP code --------@connect CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@connect CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------

## @to 
Specifies single receiver for request.
Use this to mix with other commands.
-------- PHP code --------@to CLUSTER_ADDRESS-------- !PHP code --------

## @update 
Sends update command to all clusters.
Argument specifies address to source file from whitch cluster's updaters will get new code
-------- PHP code --------@update source:SOURCE_FILE_ADDRESS-------- !PHP code --------

## @echo 
Sends echo request to all clusters. 
-------- PHP code --------@echo-------- !PHP code --------

## @sleep 
Sleeps cluster (s). Without any arguments will sleeps all clusters.
-------- PHP code --------@sleep-------- !PHP code --------

or

-------- PHP code --------@sleep CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@sleep CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------

or

Sleep my cluster:
-------- PHP code --------@sleep me-------- !PHP code --------

[i]me[/i] is an alias to THIS cluster.

## @wakeup 
Wake-ups cluster (s). Without any arguments will wake-up all clusters.
-------- PHP code --------@wakeup-------- !PHP code --------

or

-------- PHP code --------@wakeup CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@wakeup CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------

or

Wake up my cluster:
-------- PHP code --------@wakeup me-------- !PHP code --------

## @broadcast 
Enabling extended broadcast (request will be resending by clusters to each others)
-------- PHP code --------@broadcast-------- !PHP code --------

## @opt_set 
Sets cluster option on remote
-------- PHP code --------@opt_set key1:value1, key2:value2, key3:value3...-------- !PHP code --------

## @opt_get 
Gets cluster option from remote
-------- PHP code --------@opt_get key1, key2, key3...-------- !PHP code --------

## @reg_set 
Sets registry value on remote
-------- PHP code --------@reg_set key1:value1, key2:value2, key3:value3...-------- !PHP code --------

## @reg_get 
Gets registry value from remote
-------- PHP code --------@reg_get  key1, key2, key3...-------- !PHP code --------

## @clone 
Executes self-cloning command
-------- PHP code --------@clone -------- !PHP code --------

or

-------- PHP code --------@clone  CLUSTER_ADDRESS-------- !PHP code --------

or

-------- PHP code --------@clone  CLUSTER_ADDRESS1, CLUSTER_ADDRESS2, CLUSTER_ADDRESS3...-------- !PHP code --------

or

Clone my cluster:
-------- PHP code --------@clone  me-------- !PHP code --------


### 8. Compiling Skynet sources into standaloneThe main idea of Skynet is to use single standalone easy to move files as clusters. Sources placed in [i]/src[/i] folder should be compiled via built-in compile script and only compiled clusters should be used. 
Of course, you can use non-compiled versions but that is not idea of this framework.

To compile all sources (including your custom listeners and classes) into single standalone cluster just launch:

-------- PHP code --------/compile.php-------- !PHP code --------

from your browser or CLI Mode.
This will compile all sources from [i]/src[/i] into [i]/_compiled[/i] folder.
The name of the compiled file will be:

-------- PHP code --------skynet_{COMPILATION_TIME}.php-------- !PHP code --------

Compiled version includes all required classes and is ready to use.
You can also specify compiler output directory in:

-------- PHP code --------/src/Skynet/Tools/SkynetCompiler.php-------- !PHP code --------

You can also compile sources from any cluster when you launching Skynet in CLI mode:

-------- PHP code --------php skynet.php -compile-------- !PHP code --------


### 9. Skynet Control PanelSkynet Control Panel is main interface for controlling and debugging Skynet connections.
You can access Panel when you launch Skynet from internet browser. Panel is splitted into 2 views: connections and database.
Every Skynet cluster have its own Panel, you can run Panel e.g. by placing Skynet downloaded from GitHub on localhost and run [i]dev.php[/i] or [i]skynet.php[/i] in browser.


### 9.1. View: ConnectionsConnections View have 3 sections: status data (left column), connections data (right column) and webconsole (bottom).

image: img/cp_connections.jpg

## Status data 
In left column you will see most inportant informations about Skynet status.
There are 5 sections:

- Summary - informations about KEY ID, clusters in database, succesed connections and more
- Errors - list with errors 
- States - list with states of Skynet components
- Config - actual configuration

When console is in use there will be displayed once more section: Console Input.

## Connections data 
On right side you have window with all parameters whitch are sending and receiving via connections with other clusters.
If there is no connection actualy this window is empty.
Every connection data has 9 sections:

- Cluster Info - information about connected cluster
- Request Fields {sended} (plain) - raw requested to cluster fields 
- Response Fields {received} (decrypted) - encrypted fields from cluster response
- Request Fields {sended} (encrypted) - encrypted requested to cluster fields 
- Response Fields {received} (raw) - raw fields from cluster response
- SENDED PARAMS - raw sended data packet
- SENDED HEADER PARAMS (BROADCAST) - raw sended header packet (headers are ony sent in broadcast mode)
- RECEIVED RAW DATA - raw received response packet
- RECEIVED RAW HEADER (BROADCAST) - raw received response packet (headers are ony sent in broadcast mode)

All @ prefixed parameters are internal Skynet parameters.

## Webconsole 
On the bottom you have webconsole for inputing commands and parameters.
Above the console is select list with shortcuts to commands with short descriptions.

## VIEW SWITCH AND LOGOUT 
On the top right corner you have switch to change view (connections/database) and logout button.


### 9.2. View: DatabaseDatabase view allow you to access to cluster database.
On the to you will se select list where you can select actual viewing table and sort/pagination options.

Records list can be deleted via [i]Delete[/i] button.
You can also export any record to text file by clicking on [i]Generate TXT[/i] button.

image: img/cp_database.jpg

## Database tables: 

- Clusters - stores clusters data
- Registry - stores registry options`
- Options - stores configuration
- Chain - stores actual chain value
- Logs: Responses - stored responses
- Logs: Requests - stored requests
- Logs: Echo - stored echo commands
- Logs: Broadcasts - stored broadcast commands
- Logs: Errors - stored errors
- Logs: Access Errors - stored security errors (unathorized access to Panel and incorrect KEY ID in connections)
- Logs: Self-updates - stored update procedures

You can view and delete all of the records but you should not delete data from Chain and Clusters tables.


### 10. Extending & customizingSkynet architecture is easy to extend and to customize. Even core features can be replace by custom ones. In this section you will see how to customize or extends Skynet by own core elements.


### 10.1. Custom Data EncryptionBy default, Skynet offers one class for simple encryption data:

- via base64

You can create and add your own encryption method by implementing:

-------- PHP code --------/src/Skynet/Encryptor/SkynetEncryptorInterface.php-------- !PHP code --------

and adding new encryptor to:

-------- PHP code --------/src/Skynet/Encryptor/SkynetEncryptorsFactory.php-------- !PHP code --------

After that you can set encryption method in [i]/src/SkynetUser/SkynetConfig.php[/i] file by changing option:

-------- PHP code --------'core_encryptor' => 'YOUR_ENCRYPTOR',-------- !PHP code --------

Where [i]YOUR_ENCRYPTOR[/i] is the name of encryptor defined in register method in factory.


### 10.2. Custom Connection ClassesBy default, Skynet offers two connection methods:

- via [i]cURL[/i] library
- via [i]file_get_contents()[/i] function

You can create and add your own connection class by implementing:

-------- PHP code --------/src/Skynet/SkynetConnectionInterface.php-------- !PHP code --------

and registering new class in factory:

-------- PHP code --------/src/Skynet/SkynetConnectionsFactory.php-------- !PHP code --------

After that you can set connection method in [i]/src/SkynetUser/SkynetConfig.php[/i] file by changing option:

-------- PHP code --------'core_connection_type' => 'YOUR_CONNECTOR',-------- !PHP code --------

Where [i]YOUR_CONNECTOR[/i] is the name of connector defined in register method in factory.


### 10.3. Custom Commands ShortcutsSkynet offers quick shortcut commands list above webconsole.
This list is hardcoded but you can add here your own commands in:

-------- PHP code --------/src/Skynet/Console/SkynetConsole.php-------- !PHP code --------

Custom command can be added to list by:

-------- PHP code --------$this->addCommand()-------- !PHP code --------

method in class constructor.

Custom commands can be defined in Event Listeners also via

-------- PHP code --------registerCommands()-------- !PHP code --------

method.


### 10.4. Custom ThemesYou can change CSS theme of [i]Skynet Control Panel[/i] by adding different theme in file:

-------- PHP code --------/src/Skynet/Renderer/Html/SkynetRendererHtmlThemes.php-------- !PHP code --------

After that you will need to change theme name in main config file.


### 11. ConfigurationSkynet configuration is placed in /src/SkynetUser/SkynetConfig.php file.
When compiling this file is including at the beginning of compiled standalone version.

Configuration options:


[KEY_ID] - your Skynet Key ID

[PASSWORD] - admin password for Skynet Control Panel

## Core configuration - base options: 


[core_secure] -> bool:[true|false]
If TRUE, Skynet will verify KEY ID in every response, if FALSE - you will able to connect without key (USE THIS ONLY FOR TESTS!!!) 


[core_raw] -> bool:[true|false]
If TRUE all sending and receiving data will be encrypted, if FALSE - all data will be send in plain text 


[core_updater] -> bool:[true|false]
If TRUE Skynet will enable self-remote-update engine, if FALSE - self-remote-engine will be disabled 


[core_cloner] -> bool:[true|false]
Enables or disabled clone engine


[core_updater_url] -> string:[url]
Address to base file with PHP code sending to clusters on self-update operation 


[core_encryptor] -> string:[base64|...]
Name of registered class used for encrypting data 


[core_renderer_theme] -> string:[dark|light|raw|...]
Theme CSS configuration for HTML Renderer 


[core_date_format] -> string
Date format for date() function 


## Core configuration - connections with clusters: 


[core_connection_mode] -> string:[host|ip]
Specified connection addresses by host or IP 

[core_connection_type] -> string:[curl|file_get_contents|...]
Name of registered class used for connection with clusters 

[core_connection_protocol] -> string:[http|https]
Connections protocol 

[core_connection_ssl_verify] -> bool:[true|false]
Only for cURL, set to FALSE to disable verification of SSL certificates 

[core_connection_curl_cli_echo] -> bool:[true|false]
If true CURL will display connection output in CLI mode (VERBOSE OPTION) 


## Emailer configuration: 

[core_email_send] -> bool:[true|false]
TRUE for enable auto-emailer engine for responses, FALSE to disable 

[core_email_send] -> bool:[true|false]
TRUE for enable auto-emailer engine for requests, FALSE to disable 

[core_email_address] -> [email]
Specify email address for receiving emails from Skynet 


## Response: 

[response_include_request] -> bool:[true|false]
If TRUE, response will be attaching requests data with @ prefix, if FALSE requests data will not be included into response 


## Logs: 

[logs_errors_with_full_trace] -> bool:[true|false]

[logs_dir] -> string:[path/]
Specify path to dir where Skynet will save logs, or leave empty to save logs in Skynet directory 

[logs_txt_*] -> bool:[true|false]
Enable or disable txt logs for specified Event 

[logs_txt_include_internal_data] -> bool:[true|false]
If TRUE, Skynet will include internal params in txt logs 

[logs_db_*] -> bool:[true|false
Enable or disable database logs for specified Event 

[logs_db_include_internal_data] -> bool:[true|false]
If TRUE, Skynet will include internal params in database logs 



## Remote disable: 

[die_all] -> bool:[true|false]
If TRUE, Skynet will send termination command to all cluster and deactivate them 

[restore_all] -> bool:[true|false]
If TRUE, Skynet will send reactivation command to all cluster terminat by die_all 


## Database configuration: 

[db] -> bool:[true|false]
Enable or disable database support. If disabled some of functions of Skynet will not work  

[db_type] -> string:[dsn]
Specify adapter for PDO (sqlite is recommended)  

[DB connection config]
db_host
db_user
db_password
db_dbname
db_encoding
db_port

[db_file] -> string:[filename]
SQLite database filename, leave empty to let Skynet specify names itself (recommended)  

[db_file] -> string:[path/]
SQLite database path, if empty db will be created in Skynet directory  

## Debug options 

[console_debug] -> bool:[true|false]
If TRUE, console command debugger will be displayed when parsing input 

[debug_exceptions] -> bool:[true|false]
If TRUE, debugger will show more info like line, file and trace on errors 



### 12. CLI modeSkynet also works in CLI mode with different interface.
To launch Skynet in CLI mode just launch:

php skynet.php

This version of Skynet serves you some commands to use:

## -debug 
Displays connections full debug


## -dbg 
Displays connections full debug (alias)


## -cfg 
Displays configuration


## -status 
Displays status


## -out [field] or [field1, field2...] 
Displays only specified fields returned from response


## -connect [address] 
Connects to single specified address


## -c [address] 
Connects to single specified address (alias)


## -broadcast 
Broadcasts all addresses (starts Skynet)


## -b 
Broadcasts all addresses (starts Skynet) (alias)


## -send ["request params"] 
Sends request from command line, syntax of request params is the same like in webconsole


## -db [table name] optional: [page] [sortByColumn] [ASC|DESC] 
Displays logs records from specified table in database


## -db [table name] -del [record ID] 
Erases record from database table  


## -db [table name] -truncate 
Erases ALL RECORDS from database table   

 
## -sleep 
Sleeps this cluster


## -wakeup 
Wakeups this cluster


## -help 
Displays help


## -h 
Displays help (alias)

 
## -pwdgen [your password] 
Generates new password hash from plain password


## -keygen 
Generates new SKYNET ID KEY  

## -compile 
Compiles sources from [i]/src[/i] into standalone


### 13. API DocumentationFull API reference is available with PHPDOC:

[apidoc]


### 14. Updating SkynetSkynet is still in development, so if new versions will be available on GitHub you will should update your clusters with newest version.
When you will download an update with new sources you will need to recompile your version of clusters.

After download new version just replace old [i]/src/Skynet[/i] folder with new one and do not replace your code from [i]/src/SkynetUser[/i] directory. At next, just recompile your clusters. 
Your old config and listeners will be included into new version of Skynet's core.


### 15. Contact and donateLink to GitHub: [link]http://github.com/szczyglinski/skynet[//]http://github.com/szczyglinski/skynet[/link]
Link to website: [link]http://skynetframework.blogspot.com[//]http://skynetframework.blogspot.com[/link]
Email to author: [link]szczyglis83@gmail.com[//]szczyglis83@gmail.com[/link]


